local nodes = {}
local plr = game.Players.LocalPlayer
local hrp = plr.Character.HumanoidRootPart
local nodeconnection = {9, 0, 1, 2, 3, 0, 5, 6, 7, 0, 9, 10, 11, 0, 13, 14, 15, 0, 17, 18, 19}

function RandomVariable(length)
    local res = ""
    for i = 1, length do
        res = res .. string.char(math.random(97, 122))
    end
    return res
end

local DoCheck = RandomVariable(20)
_G.DoCheck = DoCheck

function Split(s, delimiter)
    local result = {}
    for match in (s..delimiter):gmatch("(.-)"..delimiter) do
        table.insert(result, match)
    end
    return result
end

local function zeroGrav(part)
    if not part:FindFirstChild("BodyForce") then 
        local temp = Instance.new("BodyForce")
        temp.Force = part:GetMass() * Vector3.new(0, workspace.Gravity, 0)
        temp.Parent = part
    end
end

_G.Enabled = true
if _G.Enabled then
    for i = 0, 20, 1 do
        for _, v in pairs(game.Workspace[plr.Name .. "Aircraft"]:GetDescendants()) do
            if v:IsA("BasePart") then
                if v.Color == Color3.fromRGB(i, i, i) then
                    table.insert(nodes, v)
                end
                zeroGrav(v)
                v.CanCollide = false
            end
        end
        task.wait(0.03)
    end
end

while _G.Enabled do
    if _G.DoCheck ~= DoCheck then
        break
    end
    task.wait(0.03)

    local url = "http://192.168.0.248:5050/"
    print("Fetching data from URL:", url)

    local success, response = pcall(function()
        return game:HttpGet(url)
    end)

    if not success then
        print("Failed to fetch data from URL:", url)
        task.wait(1)
        continue
    end

    print("Received data:", response)

    local nodesData = Split(response, "B")
    if #nodesData == 0 then
        print("No nodes data received")
    end

    for _, node in pairs(nodesData) do
        local data = Split(node, " ")
        if #data < 4 then
            print("Invalid node data:", node)
            continue
        end

        local index = tonumber(data[1])
        if not index then
            print("Invalid index in node data:", data[1])
            continue
        end
        index = index + 1
        
        if not nodes[index] then
            print("Node index out of range:", index)
            continue
        end

        local anode = nodes[index]
        local posX = tonumber(data[3])
        local posY = tonumber(data[4])
        local posZ = tonumber(data[2])

        if not posX or not posY or not posZ then
            print("Error in node position data:", data)
            continue
        end

        local pos = hrp.Position + Vector3.new(posX / 3, posY / 3, posZ / 3) + Vector3.new(-70, 100, -150)
        local connectionIndex = tonumber(nodeconnection[index])
        if not connectionIndex then
            print("Invalid connection node index:", nodeconnection[index])
            continue
        end
        connectionIndex = connectionIndex + 1

        if not nodes[connectionIndex] then
            print("Connection node index out of range:", connectionIndex)
            continue
        end

        local tolookat = CFrame.lookAt(anode.Position, nodes[connectionIndex].Position)

        if anode:FindFirstChild("bbbg") then
            anode.bbbg.CFrame = tolookat
            anode.bbbp.Position = pos
        else
            local bg = Instance.new("BodyGyro")
            bg.Parent = anode
            bg.Name = "bbbg"
            bg.MaxTorque = Vector3.new(math.huge, math.huge, math.huge)
            bg.D = 100
            bg.CFrame = tolookat
            local bp = Instance.new("BodyPosition")
            bp.Parent = anode
            bp.Name = "bbbp"
            bp.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
            bp.P = 25000
            bp.D = 1000
            bp.Position = pos
        end

        print("Updated node:", index, "Position:", pos, "CFrame:", tolookat)
    end
end
